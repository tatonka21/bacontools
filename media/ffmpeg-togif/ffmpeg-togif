#!/bin/bash
# Usage: ffmpeg-togif input.mp4 output.gif
# Convert video to gif using ffmpeg with a separate palette generation pass.
#
# ARGUMENTS
#   -n SCALE          Scale input video dimensions by SCALE.
#   -s TIME           Seek to TIME when decoding (in hh:mm:ss.cs format).
#   -t TIME           Decode TIME-long fragment.
#
# REQUIREMENTS
#   bash
#   basename
#   ffprobe
#   ffmpeg
#   tput
#   tail
#   sed
#   cat
#   tac
#   rm
#   bc

TMP_DIR="${TMP_DIR-"$(mktemp -d || exit 1)"}"
PALETTE_FILE="${PALETTE_FILE-"$TMP_DIR/.ffmpeg-togif.$$.palette.%05d.png"}"
PROGRESS_FILE="${PROGRESS_FILE-"$TMP_DIR/.ffmpeg-togif.$$.progress.txt"}"

SCALE_W="${SCALE_W-iw}"
SCALE_H="${SCALE_H-ih}"

# Usage: progress_bar WIDTH MESSAGE_SCRIPT
# Monitor stdin for progress (a decimal in [0,1]) and update a progress bar.
# ARGUMENTS
#   WIDTH             Size of the progress bar not counting the message.
#   MESSAGE           Text to display after the progress bar
# echo 0.5 | progress_bar 10 "Doing something"
# [####----] Doing something
progress_bar() {
	PB_LEFT_SEPARATOR="${PB_LEFT_SEPARATOR-[}"
	PB_RIGHT_SEPARATOR="${PB_RIGHT_SEPARATOR-]}"
	PB_EMPTY="${PB_EMPTY--}"
	PB_FILL="${PB_FILL-#}"

	WIDTH="$1"
	MESSAGE="$2"

	PB_LS_LEN="$(printf "%s" "$PB_LEFT_SEPARATOR" | wc -c)"
	PB_RS_LEN="$(printf "%s" "$PB_RIGHT_SEPARATOR" | wc -c)"
	PB_E_LEN="$(printf "%s" "$PB_EMPTY" | wc -c)"
	PB_F_LEN="$(printf "%s" "$PB_FILL" | wc -c)"
	PB_PERIOD="${PB_PERIOD-30}"
	PHASE=0

	( echo 0 ; cat ) | while IFS='' read -r PROGRESS || [ -n "$PROGRESS" ] ; do
		(
			# Once every PB_PERIOD loops, erase the line before overwriting it
			PHASE="$(( PHASE+1 ))"
			if [ "$(( PHASE / PB_PERIOD ))" -ge 1 ]; then
				PHASE=0
				printf "\033[2K"
			fi

			CURRENT_WIDTH=0
			FILL_WIDTH="$(( WIDTH - PB_LS_LEN - PB_RS_LEN ))"

			if [ "$FILL_WIDTH" -le 0 ]; then
				printf "%s%s" "$PB_LEFT_SEPARATOR" "$PB_RIGHT_SEPARATOR" 2>&1
				exit
			fi

			printf "%s" "$PB_LEFT_SEPARATOR"
			(
				CURRENT_WIDTH="$(echo "$CURRENT_WIDTH + $PB_LS_LEN" | bc)"
				if [ "$CURRENT_WIDTH" -ge "$WIDTH" ]; then
					exit
				fi

				FILL_COUNT="$(printf "%.0f" "$(echo "$FILL_WIDTH * $PROGRESS" | bc)")"
				F_COUNT="$(printf "%.0f" "$(echo "scale=3 ; 1.0*($FILL_COUNT+$PB_F_LEN/2)/$PB_F_LEN" | bc)")"
				E_COUNT="$(printf "%.0f" "$(echo "scale=3 ; 1.0*($FILL_WIDTH-$FILL_COUNT)/$PB_E_LEN + 2" | bc)")"

				if [ "$F_COUNT" = 0 ]; then
					E_COUNT="$(( E_COUNT + 1))"
				fi

				for I in $(seq 1 "$F_COUNT") ; do
					printf "%s" "$PB_FILL" 2>&1
				done

				# shellcheck disable=SC2034
				for I in $(seq 1 "$E_COUNT") ; do
					printf "%s" "$PB_EMPTY" 2>&1
				done
			) | head -c "$FILL_WIDTH"
			printf "%s" "$PB_RIGHT_SEPARATOR" 2>&1
		) | head -c "$WIDTH"

		if [ -n "$MESSAGE" ]; then
			printf " %s" "$(eval "$MESSAGE" 2>&1)"
		fi

		printf "\r"
	done

	printf "\n"
}

trim() {
	sed -e 's/^[[:space:]]*//' | sed -e 's/[[:space:]]*$//'
}

read_progress() {
	sleep 1

	# Daddy, why are all these stdbufs here?
	# Just in fucking case someone hoards their shit, honey.
	tail --follow=name "$PROGRESS_FILE" 2>/dev/null | \
	stdbuf -i0 -o0 sed -n "s/out_time_ms=\\(.*\\)/scale=4 ; \\1*1.0\\/$DURATION\\/1000/p" | \
	stdbuf -i0 -o0 bc

	echo 1
}

read_progress_once() {
	tac "$PROGRESS_FILE" 2>/dev/null | \
	sed -n "s:out_time_ms=\\(.*\\):scale=4 ; \\1*1.0/$DURATION/1000:p" 2>&1 | \
	head -1 | \
	stdbuf -i0 -o0 bc
}

# read_eta START_TIME
read_eta() {
	NOW="$(date +%s)"
	ELAPSED="$(( NOW - START ))"
	PR="$(read_progress_once)"
	RESULT="$(printf "%s" "$(echo "$ELAPSED $PR" | awk '{if ($2+0 != 0) printf "%.1f", ($1/$2-$1)/60}')")"

	if [ -z "$RESULT" ]; then
		RESULT=0
	fi

	printf "%4s" "$RESULT"
}

get_video_duration() {
	echo "$(ffprobe -select_streams v:0 -show_entries "format=duration" -of compact "$1" 2>/dev/null | sed 's!.*=\(.*\)!\1!g')*1000" | \
	bc
}

while getopts :n:s:t: OPTION ; do
	case "$OPTION" in
		n)
			echo "Setting scale to $OPTARG" 1>&2
			SCALE_W="$OPTARG*iw"
			SCALE_H="-1"
			;;
		s)
			SEEK="$OPTARG"
			SEEK_ARG="-ss $SEEK"
			;;
		t)
			TIME="$OPTARG"
			TIME_ARG="-t $TIME"
			;;
		\?)
			echo "Invalid option '-$OPTARG'" 1>&2
			echo "Read the source code for usage information" 1>&2
			exit 1
			;;
		:)
			echo "Option '-$OPTARG' requires an argument" 1>&2
			exit 1
			;;
		*)
			echo "This case catch-all is not supposed to happen" 1>&2
			echo '\o/' 1>&2
			exit 1
	esac
done

shift "$(( OPTIND-1 ))"

INPUT="$1"
OUTPUT="$2"
shift 2

if [ -z "$INPUT" ]; then
	echo "$(basename "$0"): input file not provided, exiting" 1>&2
	exit 1
fi

if [ -z "$OUTPUT" ]; then
	echo "$(basename "$0"): output path not provided, exiting" 1>&2
	exit 1
fi

if   [ ! -e "$INPUT" ]; then
	echo "$(basename "$0"): input file does not exist" 1>&2
	exit 1
elif [ ! -r "$INPUT" ]; then
	echo "$(basename "$0"): input file is not readable" 1>&2
	exit 1
fi

inttrap() {
	tput cnorm
	rm -rf "$TMP_DIR"
	exit
}

# shellcheck disable=SC2064
trap inttrap INT

if [ -e "$OUTPUT" ]; then
	read -r -e -p "File '$OUTPUT' exists; overwrite? [y/N] " DO_OVERWRITE
	DO_OVERWRITE="$(printf "%s" "$DO_OVERWRITE" | trim | cut -c1)"

	if [ "$DO_OVERWRITE" != "y" ] && [ "$DO_OVERWRITE" != "Y" ]; then
		exit 1
	fi
fi

DURATION="$(get_video_duration "$INPUT")"

# Hide cursor
tput civis

echo "Calculating palette..." 1>&2
# shellcheck disable=SC2086
ffmpeg -loglevel error -y $SEEK_ARG $TIME_ARG -i "$INPUT" \
-vf "scale=$SCALE_W:$SCALE_H:flags=lanczos,palettegen=stats_mode=single" \
"$PALETTE_FILE"

START="$(date +%s)"

# shellcheck disable=SC2016
( read_progress | progress_bar 40 'echo "Converting... (ETA $(read_eta)m)"' ) &
# shellcheck disable=SC2086
ffmpeg -progress "$PROGRESS_FILE" -loglevel error \
$SEEK_ARG $TIME_ARG -i "$INPUT" -i "$PALETTE_FILE" \
-lavfi "[0:v]scale=$SCALE_W:$SCALE_H:flags=lanczos[s];[s][1:v]paletteuse=new=1" \
-y "$OUTPUT"
rm "$PROGRESS_FILE"
wait

inttrap
