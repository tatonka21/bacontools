#!/bin/bash
# Usage: ffmpeg-togif input.mp4 output.gif
# Convert video to gif using ffmpeg with a separate palette generation pass.
#
# REQUIREMENTS
#   bash
#   basename
#   ffprobe
#   ffmpeg
#   tput
#   tail
#   sed
#   rm
#   bc

INPUT="$1"
OUTPUT="$2"
shift 2

TMP_DIR="${TMP_DIR-"$(pwd)"}"
PALETTE_FILE="${PALETTE_FILE-"$TMP_DIR/.ffmpeg-togif.$$.palette.png"}"
PROGRESS_FILE="${PROGRESS_FILE-"$TMP_DIR/.ffmpeg-togif.$$.progress.txt"}"

SCALE_W="${SCALE_W-iw}"
SCALE_H="${SCALE_H-ih}"

# Usage: progress_bar WIDTH MESSAGE_SCRIPT
# Monitor stdin for progress (a decimal in [0,1]) and update a progress bar.
# ARGUMENTS
#   WIDTH             Size of the progress bar not counting the message.
#   MESSAGE           Text to display after the progress bar
#
# echo 0.5 | progress_bar 10 "Doing something"
# [####----] Doing something
progress_bar() {
	PB_LEFT_SEPARATOR="${PB_LEFT_SEPARATOR-[}"
	PB_RIGHT_SEPARATOR="${PB_RIGHT_SEPARATOR-]}"
	PB_EMPTY="${PB_EMPTY--}"
	PB_FILL="${PB_FILL-#}"

	WIDTH="$1"
	MESSAGE="$2"

	PB_LS_LEN="$(printf "%s" "$PB_LEFT_SEPARATOR" | wc -c)"
	PB_RS_LEN="$(printf "%s" "$PB_RIGHT_SEPARATOR" | wc -c)"
	PB_E_LEN="$(printf "%s" "$PB_EMPTY" | wc -c)"
	PB_F_LEN="$(printf "%s" "$PB_FILL" | wc -c)"

	( echo 0 ; cat ) | while IFS='' read -r PROGRESS || [ -n "$PROGRESS" ] ; do
		(
			CURRENT_WIDTH=0
			FILL_WIDTH="$(( WIDTH - PB_LS_LEN - PB_RS_LEN ))"

			if [ "$FILL_WIDTH" -le 0 ]; then
				printf "%s%s" "$PB_LEFT_SEPARATOR" "$PB_RIGHT_SEPARATOR" 2>&1
				exit
			fi

			printf "%s" "$PB_LEFT_SEPARATOR"
			(
				CURRENT_WIDTH="$(echo "$CURRENT_WIDTH + $PB_LS_LEN" | bc)"
				if [ "$CURRENT_WIDTH" -ge "$WIDTH" ]; then
					exit
				fi

				FILL_COUNT="$(printf "%.0f" "$(echo "$FILL_WIDTH * $PROGRESS" | bc)")"
				F_COUNT="$(printf "%.0f" "$(echo "scale=3 ; 1.0*($FILL_COUNT+$PB_F_LEN/2)/$PB_F_LEN" | bc)")"
				E_COUNT="$(printf "%.0f" "$(echo "scale=3 ; 1.0*($FILL_WIDTH-$FILL_COUNT)/$PB_E_LEN + 2" | bc)")"

				if [ "$F_COUNT" = 0 ]; then
					E_COUNT="$(( E_COUNT + 1))"
				fi

				for I in $(seq 1 "$F_COUNT") ; do
					printf "%s" "$PB_FILL" 2>&1
				done

				# shellcheck disable=SC2034
				for I in $(seq 1 "$E_COUNT") ; do
					printf "%s" "$PB_EMPTY" 2>&1
				done
			) | head -c "$FILL_WIDTH"
			printf "%s" "$PB_RIGHT_SEPARATOR" 2>&1
		) | head -c "$WIDTH"

		if [ -n "$MESSAGE" ]; then
			printf " %s" "$(eval "$MESSAGE" 2>&1)"
		fi

		printf "\r"
	done
}

trim() {
	sed -e 's/^[[:space:]]*//' | sed -e 's/[[:space:]]*$//'
}

read_progress() {
	sleep 1

	# Daddy, why are all these stdbufs here?
	# Just in fucking case someone hoards their shit, honey.
	tail --follow=name "$PROGRESS_FILE" 2>/dev/null | \
	stdbuf -i0 -o0 sed -n "s/out_time_ms=\\(.*\\)/scale=4 ; \\1*1.0\\/$DURATION\\/1000/p" | \
	stdbuf -i0 -o0 bc

	echo 1
}

read_progress_once() {
	# Daddy, why are all these stdbufs here?
	# Just in fucking case someone hoards their shit, honey.
	tac "$PROGRESS_FILE" 2>/dev/null | \
	sed -n "s:out_time_ms=\\(.*\\):scale=4 ; \\1*1.0/$DURATION/1000:p" 2>&1 | \
	head -1 | \
	stdbuf -i0 -o0 bc
}

# read_eta START_TIME
read_eta() {
	NOW="$(date +%s)"
	ELAPSED="$(( NOW - START ))"
	PR="$(read_progress_once)"
	printf "%s" "$(echo "$ELAPSED $PR" | awk '{printf "%.1f", ($1 / ($2 + 0.001) - $1) / 60}')"
}

get_video_duration() {
	echo "$(ffprobe -select_streams v:0 -show_entries "format=duration" -of compact "$1" 2>/dev/null | sed 's!.*=\(.*\)!\1!g')*1000" | \
	bc
}

if [ -z "$INPUT" ]; then
	echo "$(basename "$0"): input file not provided, exiting" 1>&2
	exit 1
fi

if [ -z "$OUTPUT" ]; then
	echo "$(basename "$0"): output path not provided, exiting" 1>&2
	exit 1
fi

if   [ ! -e "$INPUT" ]; then
	echo "$(basename "$0"): input file does not exist" 1>&2
	exit 1
elif [ ! -r "$INPUT" ]; then
	echo "$(basename "$0"): input file is not readable" 1>&2
	exit 1
fi

# shellcheck disable=SC2064
trap "tput cnorm ; rm -fv '$PROGRESS_FILE' '$PALETTE_FILE' ; exit" INT

if [ -e "$OUTPUT" ]; then
	read -r -e -p "File '$OUTPUT' exists; overwrite? [y/N] " DO_OVERWRITE
	DO_OVERWRITE="$(printf "%s" "$DO_OVERWRITE" | trim | cut -c1)"

	if [ "$DO_OVERWRITE" != "y" ] && [ "$DO_OVERWRITE" != "Y" ]; then
		exit 1
	fi
fi

rm -rfv "$PALETTE_FILE" "$PROGRESS_FILE"

DURATION="$(get_video_duration "$INPUT")"

# Hide cursor
tput civis

echo "Calculating palette..." 1>&2
ffmpeg -loglevel error -y -i "$INPUT" -vf palettegen "$PALETTE_FILE"

START="$(date +%s)"

# shellcheck disable=SC2016
( read_progress | progress_bar 40 'echo "Converting... (ETA $(read_eta)m)"' ) &
ffmpeg -progress "$PROGRESS_FILE" -loglevel error \
-i "$INPUT" -i "$PALETTE_FILE" -lavfi "[0:v][1:v] paletteuse" -y "$OUTPUT"
rm "$PROGRESS_FILE"
wait

rm "$PALETTE_FILE"

# Show cursor
tput cnorm
